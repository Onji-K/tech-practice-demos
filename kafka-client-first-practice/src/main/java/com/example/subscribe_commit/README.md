# 커밋

## enable.auto.commit 설정
기본적으로는 `enable.auto.commit=true` 로 설정되어 있다.
이렇게 설정되어 있으면, 컨슈머 클라이언트에서 `poll()` 메서드를 호출할 때, `auto.commit.interval.ms` 에 설정된 주기가 지났으면 커밋을 진행한다.

하지만 이렇게 하면, 다음과 같을 때 문제가 생긴다.

- `poll()` 메서드 호출 이후 리밸런싱이 되는 경우
- `poll()` 메서드 호출 이후 컨슈머 강제종료가 발생하는 경우

이런 경우, 제대로 처리되지 않았는데, 커밋이 진행되게 되므로, 데이터가 중복으로 처리되거나, 유실 될 수 있다.

그래서 데이터의 중복이나 유실을 허용하지 않는 서비스라면 자동커밋을 사용하면 안된다.

## 명시적 커밋

명시적 커밋을 하면, `enable.auto.commit=false`로 설정하고, 직접 커밋하는 코드를 작성해 주어야 한다.

커밋에는 두가지 방식이 있다. 동기와 비동기 이다.

### 동기 커밋

`commitSync()` 메서드를 사용한다.

단점은 브로커에 커밋 요청을 보내고, 응답을 받을 때까지 블로킹이 된다는 것이다.

따라서 데이터 처리 시간에 비해 커밋 시간이 길어지면, 처리량이 떨어지게 된다.

ex) 한번 poll() -> 매우 짧은 처리 -> 동기 커밋

### 비동기 커밋

`commitAsync()` 메서드를 사용한다.

단점은 커밋 요청이 실패했을 경우,
- 현재 처리 중인 데이터의 순서를 보장하지 않는다.
- 데이터의 중복 처리가 발생할 수 있다.

### 커밋 시점

당연하겠지만, `poll()`로 받은 모든 데이터를 처리한 다음 커밋을 날려야한다.

`poll()`은 가장 마지막으로 받은 레코드의 오프셋을 기준으로 커밋하기 때문이다.

## 데이터의 중복 처리

`poll()`메서드의 데이터가 모두 처리되기 전에 리밸런스가 발생하게되면 데이터가 중복 처리될 수 있다.